---
layout: post
title: "알고리즘 문제풀이 - 백준 12783"
tags: [알고리즘, 백준]
comments: true
---

# 백준 12783 < 곱셈게임 >

문제 : <https://www.acmicpc.net/problem/12783>

### 1. 고민했던 점

1. 곱셈카드를 최소로 사용하는 경우를 어떤 방법으로 구할까



### 2. 해결

**1.  곱셈카드를 최소로 사용하는 경우를 어떤 방법으로 구할까**

- 재귀를 사용해서 문제를 해결하자

  - 가지고 있는 카드로 나눠질 때 그 몫을 재귀로 다시 호출
    - 예) 64를 구해야하고 2를 갖고 있다면 32를 다시 호출하면서 반복
  - 문제는 최소개수를 판별하기가 어렵고 필요한 경우를 그 때 그 때 구해줘야함.
  - 다음 쿼리에서 반복할 경우에도 중복으로 값을 구해야함 
  - 가지고 있는 카드 뿐 아니라 새로 곱셈카드 없이 만들어진 경우에 처리가 어려움.

- **dp(다이나믹 프로그래밍)를 이용하자(채택!!)**

  - 1~maxquery(query값 중 값이 제일 큰 쿼리)까지를 dp로 값을 구한다.

  - dp[i] 는 i까지 사용한 최소 곱셈카드의 개수

  - 값을 구할 때 곱셈카드가 필요 없는 경우인지 미리 체크!! 

    - 필요없으면 값을 10으로 나눠주면서 그 값이 내가 갖고 있는 카드 중에 있는지 비교하며 구한다.

    ```c++
    while (1) {
    	for (int i = 0; i < N; i++) {
    		if (tmp_num % 10 == cards[i]) {
    			tmp_num /= 10;
    			if (tmp_num == 0) return 0;
    			break;
    		}
    		if (i == N - 1) tmp_num = -1;
    	}
    	if (tmp_num < 0) break;
    }
    ```

    

  - dp로 값을 비교할 때 *곱셈카드 없이 만들어진 경우* 로도 나눠지는 확인 필요

    - 이 때 구하고자하는 숫자까지 전부 볼 필요없이 제곱근값까지만 확인하면 된다.(나머진 짝꿍)

  - dp[i]  + dp[num/i] + 1 과 현재 최솟값을 비교해서 최솟값을 dp에 넣어준다.

  ```c++
  //곱셈 카드 쓰는 경우 
  int min_val = INF;
  for (int i = 2; i <=sqrt(num) ; i++) {
  	if (dp[i] != 0) continue;
  	if (num%i == 0 && dp[num / i] != -1)
  		min_val = min(min_val, dp[i] + dp[num/i] + 1);	
  }
  if (min_val == INF) min_val = -1;
  return min_val;
  ```



### 3. 느낀점

dp는 항상 생각하기까지가 너무 어렵다. 곱셈카드없이 만들어진 경우를 제대로 확인해주지 않아 틀렸었는데 항상 예외까지 생각해줘야겠다. 그리고 0으로 나눠주는 경우를 생각하지못해 런타임에러가 떴었는데 그런 부분까지 항상 꼼꼼하게 확인하자!! 학교 대회문제로 나온거라 구글에도 정보가 많이 없고, 별도 테스트케이스도 없어서 내가 직접 만들어서 예외를 찾았는데 굉장히 좋은 경험이었던것 같다. 앞으로도 귀찮아하지말고! 테스트케이스까지 만들어 풀어보는 습관을 들이자:-)

전체코드:  [github.com/bbom16](https://github.com/bbom16/study_algorithm/blob/master/algorithm_2019_cplus/algorithm_2019_cplus/b12783.cpp)

