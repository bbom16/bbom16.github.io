---
layout: post
title: "알고리즘 문제풀이 - 백준 2775"
tags: [알고리즘, 백준]
comments: true
---

# **백준 2775 < 부녀회장이 될테야 >**

### 1. 문제
평소 반상회에 참석하는 것을 좋아하는 주희는 이번 기회에 부녀회장이 되고 싶어 각 층의 사람들을 불러 모아 반상회를 주최하려고 한다.

이 아파트에 거주를 하려면 조건이 있는데, “a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다” 는 계약 조항을 꼭 지키고 들어와야 한다.

아파트에 비어있는 집은 없고 모든 거주민들이 이 계약 조건을 지키고 왔다고 가정했을 때, 주어지는 양의 정수 k와 n에 대해 k층에 n호에는 몇 명이 살고 있는지 출력하라. 단, 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다.

### 2. 문제 이해
1. k층의 n호에는 (k-1)층의 1~n호까지 사람들의 수의 합만큼 살아야함.
2. 0층이 존재하며, 0층의 i호에는 i명만큼의 사람이 거주.

### 3. 문제 해결

#### **알고리즘**
- k층의 n호 사람 수는 그 전 k-1층의 1~n호 사람 수를 알아야하고, 그러려면 k-2층의 1~n호 사람 수.... 0층의 1~n호 사람 수가 필요하다. 그렇기 때문에 **DP** 를 이용하여 문제 해결.
```
for i in n:  
  dp[k][n] += dp[k][i]
```


#### **문제 해결**
1. dp 배열을 선언하여 1층부터 시작해서 k층까지 1호부터 n호까지의 사람 수를 구해 저장한다.

```
for i in k:
  for j in n:
    for s in j:
      dp[i][j] += dp[i-1][s]

```

2. dp[k][n]값을 출력한다.

3. 전체코드

```c
#include <stdio.h>

int main(int argc, char * argv[])
{
    int T, k, n;    //k층 n호
    int dp[15][15] = {0,};
    scanf("%d", &T);

    while(T--){
        scanf("%d %d", &k, &n);

        /* 0층의 i호는 i명 거주 */
        for(int i=1; i<=n; i++)
            dp[0][i] = i;

        for (int i=1; i<=k; i++) {
            for(int j=1; j<=n; j++){
                for(int s=1; s<=j; s++)
                    dp[i][j] += dp[i-1][s];
            }
        }

        printf("%d\n", dp[k][n]);

        /* 이차원 배열 초기화 */
        for(int i=0; i<=k; i++){
            for(int j=0; j<=n; j++)
                dp[i][j] = 0;
        }

    }


    return 0;
}

```
