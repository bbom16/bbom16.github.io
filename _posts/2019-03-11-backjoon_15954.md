---
layout: post
title: "알고리즘 문제풀이 - 백준 15954"
tags: [알고리즘, 백준, 카카오 코딩테스트]
comments: true
---

# **백준 15954 < 인형들 >**

### 1. 문제

카카오프렌즈 스토어에서는 *N*종류의 인형을 팔고 있다. *N*개의 인형들 중에서는 잘 팔리는 인형과 그렇지 않은 인형들이 섞여 있어서 잘 팔리는 인형은 상대적으로 사람들이 많이 볼 수 있는 곳에 배치하고, 잘 팔리지 않는 인형은 상대적으로 사람들이 적게 볼 수 있는 곳에 배치한다. 그러므로 배치된 곳이 가까운 두 인형은 상대적으로 판매량이 비슷하다고 할 수 있다.

좋은 배치를 정하기 위해서 어느 날, 여러 명의 사람들을 대상으로 인형의 선호도를 조사하였다. 조사 결과 각 인형에 대해서 선호하는 사람의 수를 모두 구하였고, 그에 따라 인형의 배치를 정하려고 한다.

카카오프렌즈 스토어를 관리하는 브라이언은 어떠한 특정한 곳에 인형들을 배치하고자 하는데, 그곳에 인형들을 선택하는 방법은 다음과 같다:

- 먼저 비슷한 인형이 가깝게 위치하도록 서로 다른 *N*개의 인형을 종류당 한 개씩 일렬로 배치한다.
- 그 후, 선호하는 사람의 수의 표준편차가 최소가 되는, *K*개 이상의 연속된 위치에 있는 인형들을 선택하여 그들을 같은 곳에 배치한다.

위의 방법으로 인형들을 선택했을 때, 선택된 인형들의 선호하는 사람의 수의 표준편차를 구하여라.

*N*개의 수 *a1*, *a2*, …, *aN*이 주어져 있을 때, 통계학에서 (산술) 평균은 (*a1* + *a2* + … + *aN*) / *N* 으로 정의한다. 이를 *m*으로 정의하자. 또한, 분산은 ((*a1* - *m*)2 + (*a2* - *m*)2 + … + (*aN* - *m*)2) / *N*으로 정의하고, 표준 편차는 분산의 음이 아닌 제곱근으로 정의한다.

### 2. 문제 이해 

1. 연속된 인형들의 표준편차를 구한다.(사실 분산을 구해서 최솟값만 표준편차로 출력)

2. 'K개 이상!!!!!'이다.

3. 오차값에 제한이 있기 때문에 long double형을 사용했다.

4. dfs는 재귀를 이용하여 구현한다.

5. bfs는 재귀 + 큐를 이용해서 구현한다.

6. 도착한 순서대로 출력해야하므로, 큐를 이용하여 방문 정점들을 저장한다. 

### 3.문제 해결

#### **알고리즘**

1. 연속된 k개의 인형들의 분산을 구한다.
2. 반복적으로 분산을 구해 그 중 최솟값을 찾는다.
3. k개 이상이기 때문에 k값을 증가시키면서 분산들을 구해 최솟값을 찾는다.

#### **알고리즘 구현**

1. k개 이상의 연속된 인형들의 최소 분산구하기

   ```c++
    while(K<=N){
           for(i=1; i<=N-K+1; i++){
               for(int j=0; j<K; j++){
                   averge += dolls[i+j];
               }
               averge /= K;
               for(int j=0; j<K; j++){
                   vunsan += pow(dolls[i+j]-averge,2);
               }
               vunsan /= K;
               
               if(min_diff > vunsan)
                   min_diff = vunsan;
               averge = 0; vunsan = 0;
           }
           K++;
       }
   ```

2. 전체 코드

   ```c++
   //
   //  15954_kakao_B.cpp
   //  algorithm_2019_cplus
   //  카카오 예선
   
   #include <iostream>
   #include <cmath>
   
   using namespace std;
   
   int main(int argc, char * argv[])
   {
       int N,K,i;
       long double dolls[501];
       
       cin >> N >> K;
       for(i=1; i<N+1; i++)
           cin >> dolls[i];
       
       /* 최댓값을 더 키웠어야 햇음 */
       long double min_diff = 999999999999;
       long double averge = 0, vunsan = 0;
       while(K<=N){
           for(i=1; i<=N-K+1; i++){
               for(int j=0; j<K; j++){
                   averge += dolls[i+j];
               }
               averge /= K;
               for(int j=0; j<K; j++){
                   vunsan += pow(dolls[i+j]-averge,2);
               }
               vunsan /= K;
               
               if(min_diff > vunsan)
                   min_diff = vunsan;
               averge = 0; vunsan = 0;
           }
           K++;
       }
       /* 자릿수 소수점 아래 11까지 설정 */
       cout << fixed;
       cout.precision(11);
       cout << sqrt(min_diff) << endl;
       return 0;
   }
   
   ```

#### 기타 

- cout << fixed; cout.precison(11); 알아두기
- 문제 자체는 어렵지 않았으나 자료형이나 최대값 설정 등 세부적인 것이 힘들었다. 세세하게 연습하고 기본적인 것부터 탄탄히 해야될 거 같다. 최대값이 9*10^12일 때만 맞는다. 왜 그런지 찾아보자.

문제 : <https://www.acmicpc.net/problem/15954>